# -*- coding: utf-8 -*-
"""Hackathon 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wB2wAkv7bHDuBWCEWEe6o6p9OYum__Bh
"""

!pip install pyforest

# import all the libraries
import pyforest
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
import pickle
import re
import joblib
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.ensemble import RandomForestRegressor

FILE_PATH = "https://raw.githubusercontent.com/HarpyTech/DSAI-MTech/main/ML-1/data-sets/hackathon/train.csv" #@param {type:"string"}

house_prices = pd.read_csv(FILE_PATH)

house_prices.head()

TEST_FILE_PATH = "https://raw.githubusercontent.com/HarpyTech/DSAI-MTech/main/ML-1/data-sets/hackathon/test.csv" #@param {type:"string"}

test_data = pd.read_csv(TEST_FILE_PATH)

test_data.head()

class TotalSqFtTransformer(BaseEstimator, TransformerMixin):
    def __init__(self):
        pass

    def fit(self, X, y=None):
        return self

    def transform(self, X, y=None):
        total_sqft = X['total_sqft']
        total_sqmts = total_sqft.apply(self.convert_to_sqft) * 0.09290304
        X['total_sqft'] = total_sqmts
        # X.drop(columns=['total_sqft'], inplace=True)

        return X

    @staticmethod
    def convert_to_sqft(x):
      tokens = x.split('-')
      if len(tokens) == 2:
          return (float(tokens[0]) + float(tokens[1])) / 2
      try:
          return float(x)
      except:
          try:
            if 'Sq. Meter' in x:
                num = float(re.findall("(\d+\.\d+|\d+)", x)[0])
                return num * 10.7639
            elif 'Sq. Yards' in x:
                num = float(re.findall("(\d+\.\d+|\d+)", x)[0])
                return num * 9
            elif 'Acres' in x:
                num = float(re.findall("(\d+\.\d+|\d+)", x)[0])
                return num * 43560
            elif 'Cents' in x:
                num = float(re.findall("(\d+\.\d+|\d+)", x)[0])
                return num * 435.6
            elif 'Guntha' in x:
                num = float(re.findall("(\d+\.\d+|\d+)", x)[0])
                return num * 1089
            elif 'Grounds' in x:
                num = float(re.findall("(\d+\.\d+|\d+)", x)[0])
                return num * 2400
          except:
              return np.NaN

class SizeTransformer(BaseEstimator, TransformerMixin):
    def __init__(self):
        pass

    def fit(self, X, y=None):
        return self

    def transform(self, X, y=None):
        size = X['size']
        bhk = size.apply(self.safe_extract_int)
        X['size'] = bhk

        return X

    @staticmethod
    def safe_extract_int(x):
        try:
          return int(x.split(' ')[0])
        except (ValueError, IndexError, AttributeError):
          return np.NaN

class DataTransformer(BaseEstimator, TransformerMixin):
    def __init__(self, columns=[]):
        self.columns = columns

        pass


    def fit(self, X, y=None):
        return self

    def transform(self, X, y=None):
        X = TotalSqFtTransformer().transform(X)
        X = SizeTransformer().transform(X)

        self.data_set = X
        self.numerical_columns = X.select_dtypes(include=['int64', 'float64']).columns
        self.categorical_columns = X.select_dtypes(include=['object']).columns

        if self.columns:
          [self.fill_na(column=column, X=X) for column in self.columns]
          [self.apply_capping(column=column, X=X) for column in self.columns]

          X = X[self.columns] if self.columns else X
        else:
          [self.fill_na(column=column, X=X) for column in self.numerical_columns]
          [self.fill_na(column=column, X=X, is_mode=True) for column in self.categorical_columns]
          [self.apply_capping(column=column, X=X) for column in self.numerical_columns]

        return X

    @staticmethod
    def apply_capping(column, X):
        Q1 = X[column].quantile(0.25)
        Q3 = X[column].quantile(0.75)
        IQR = Q3 - Q1

        # Define the upper and lower bounds
        upper_bound = Q3 + 1.5 * IQR
        lower_bound = Q1 - 1.5 * IQR
        q_10 = X[column].quantile(0.10)
        q_90 = X[column].quantile(0.9)

        # Apply capping
        X[column] = np.where(X[column] < lower_bound, q_10, X[column])
        X[column] = np.where(X[column] > upper_bound, q_90, X[column])

        return X

    @staticmethod
    def fill_na(column, X, is_mode=False):
        X[column].fillna(X[column].mode() if is_mode else X[column].median(), inplace=True)

        return X

data_set = DataTransformer().transform(house_prices.copy())

data_set.head()

data_set.isnull().sum()

sns.barplot(data_set.location.value_counts())

locations = pd.DataFrame(data_set.location.value_counts())
locations.head()

locations.columns

locations.reset_index().head()

locations[locations['count'] < 3].shape

# Select numerical columns
num_cols = data_set.select_dtypes(include=['int64', 'float64']).columns

# Create subplots
fig, axes = plt.subplots(nrows=len(num_cols), figsize=(8, 4 * len(num_cols)))

# Plot distplot for each numerical column
for i, col in enumerate(num_cols):
    sns.distplot(data_set[col], ax=axes[i])
    axes[i].set_title(f'Distribution of {col}')

plt.tight_layout()
plt.show()

sm.OLS(data_set['price'], sm.add_constant(data_set[['total_sqft']])).fit().summary()

sm.OLS(data_set['price'], sm.add_constant(data_set[['total_sqft', 'size']])).fit().summary()

sm.OLS(data_set['price'], sm.add_constant(data_set[['total_sqft', 'bath']])).fit().summary()

sm.OLS(data_set['price'], sm.add_constant(data_set[['total_sqft', 'balcony']])).fit().summary()

data_set.location.fillna(data_set.location.mode()[0], inplace=True)

data = data_set[['total_sqft', 'bath', 'price', 'location', 'size']]

data.head()

data = pd.get_dummies(data, columns=['location'], dtype=int)

data.head()

sm.OLS(data['price'], sm.add_constant(data.drop(columns=['price', 'size']))).fit().summary()

sm.OLS(data['price'], sm.add_constant(data.drop(columns=['price', 'bath']))).fit().summary()

LinearRegression().fit(data.drop(columns=['price']), data['price']).score(data.drop(columns=['price']), data['price'])

LinearRegression().fit(data.drop(columns=['price', 'bath']), data['price']).score(data.drop(columns=['price', 'bath']), data['price'])

LinearRegression().fit(data.drop(columns=['price', 'size']), data['price']).score(data.drop(columns=['price', 'size']), data['price'])

data.head()

data_set.head()

test_data_set = DataTransformer().transform(test_data.copy())

test_data_set.head()

# Numerical Columns
num_clos = ['total_sqft', 'bath', 'size']

# Categorical Columns
cat_clos = ['location']

num_pipe = Pipeline(steps=[
    ('pre_process', DataTransformer(columns=num_clos)),
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

cat_pipe = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('encoder', OneHotEncoder())
])

preprocessor = ColumnTransformer(transformers=[
    ('num', num_pipe, num_clos),
    ('cat', cat_pipe, cat_clos)
], remainder='passthrough')

full_pipe_rfr = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', RandomForestRegressor())
])

features = house_prices[['total_sqft', 'bath', 'location', 'size']]

full_pipe_rfr.fit(features, house_prices['price'])

full_pipe_rfr.score(features, house_prices['price'])

from sklearn.linear_model import LinearRegression

full_pipe_lr = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', LinearRegression()   )
])

features = house_prices[['total_sqft', 'bath', 'location', 'size']]

full_pipe_lr.fit(features, house_prices['price'])

full_pipe_lr.score(features, house_prices['price'])

test_data.head()

rfr_output = full_pipe_rfr.predict(test_data[features.columns])

lr_output = full_pipe_lr.predict(test_data[features.columns])

# LabelEncoder
from sklearn.preprocessing import OrdinalEncoder

# Numerical Columns
num_clos = ['total_sqft', 'bath', 'size']

# Categorical Columns
cat_clos = ['location']

num_pipe = Pipeline(steps=[
    ('pre_process', DataTransformer(columns=num_clos)),
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

cat_pipe = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('encoder', OrdinalEncoder()) # Alternative to the Label Encoder
])

preprocessor = ColumnTransformer(transformers=[
    ('num', num_pipe, num_clos),
    ('cat', cat_pipe, cat_clos)
], remainder='passthrough')

full_pipe_rfr_label = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', RandomForestRegressor())
])

features = house_prices[['total_sqft', 'bath', 'location', 'size']]

full_pipe_rfr_label.fit(features, house_prices['price'])

full_pipe_rfr_label.score(features, house_prices['price'])

label_out = full_pipe_rfr_label.predict(test_data[features.columns])

# Numerical Columns
num_clos = ['total_sqft', 'bath', 'size']

num_pipe = Pipeline(steps=[
    ('pre_process', DataTransformer(columns=num_clos)),
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

preprocessor = ColumnTransformer(transformers=[
    ('num', num_pipe, num_clos)
], remainder='passthrough')

full_pipe_rfr_label = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', RandomForestRegressor())
])

# RandomForestRegressor for these features it gave the 0.4733 as score values
# LinearRegression giving 0.3430 as score value
full_pipe_rfr_label.fit(house_prices[num_clos], house_prices['price'])

full_pipe_rfr_label.score(house_prices[num_clos], house_prices['price'])

label_out = full_pipe_rfr_label.predict(test_data[num_clos]) # This Got 144 RMSE

pd.DataFrame({'id': test_data['ID'], 'price': label_out}).to_csv('submission.csv', index=False)

distance = pd.read_csv("./dist_from_city_centre.csv")
distance.head()

rent = pd.read_csv("./avg_rent.csv")

rent.head()

house_prices = house_prices.merge(distance, on='location').merge(rent, on='location')

house_prices.head()

house_prices.isnull().sum()

test_data = test_data.merge(distance, on='location').merge(rent, on='location')

test_data.isnull().sum()

house_prices.describe()

# Numerical Columns
num_clos = ['total_sqft', 'bath', 'size', 'dist_from_city', 'avg_2bhk_rent']

num_pipe = Pipeline(steps=[
    ('pre_process', DataTransformer(columns=num_clos)),
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

preprocessor = ColumnTransformer(transformers=[
    ('num', num_pipe, num_clos)
], remainder='passthrough')

full_pipe_rfr_label = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', RandomForestRegressor())
])

# RandomForestRegressor for these features it gave the 0.4733 as score values
# LinearRegression giving 0.3430 as score value
full_pipe_rfr_label.fit(house_prices[num_clos], house_prices['price'])

full_pipe_rfr_label.score(house_prices[num_clos], house_prices['price'])

label_out = full_pipe_rfr_label.predict(test_data[num_clos]) # This Got 144 RMSE

pd.DataFrame({'ID': test_data['ID'], 'price': label_out}).to_csv('submission3.csv', index=False)

house_prices.shape, test_data.shape

rent_dict = dict({})

for location, rent in zip(rent['location'], rent['avg_2bhk_rent']):
  rent_dict[location] = rent

rent_dict

dist_dict = dict({})

for location, dist in zip(distance['location'], distance['dist_from_city']):
  dist_dict[location] = dist

dist_dict

house_prices['avg_rent'] = house_prices['location'].map(rent_dict)

house_prices['dist_from_city'] = house_prices['location'].map(dist_dict)

house_prices.describe()

test_data['avg_rent'] = test_data['location'].map(rent_dict)

test_data['dist_from_city'] = test_data['location'].map(dist_dict)

test_data.describe()

# Numerical Columns
num_clos = ['total_sqft', 'bath', 'size', 'dist_from_city']

num_pipe = Pipeline(steps=[
    ('pre_process', DataTransformer(columns=num_clos)),
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

preprocessor = ColumnTransformer(transformers=[
    ('num', num_pipe, num_clos)
], remainder='passthrough')

full_pipe_rfr_label = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', RandomForestRegressor())
])

full_pipe_rfr_label.fit(house_prices[num_clos], house_prices['price'])

full_pipe_rfr_label.score(house_prices[num_clos], house_prices['price'])

label_out = full_pipe_rfr_label.predict(test_data[num_clos]) # This Got 134.82 RMSE

pd.DataFrame({'ID': test_data['ID'], 'price': label_out}).to_csv('submission3.csv', index=False)

# Numerical Columns
num_clos = ['total_sqft', 'size', 'dist_from_city']

num_pipe = Pipeline(steps=[
    ('pre_process', DataTransformer(columns=num_clos)),
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

preprocessor = ColumnTransformer(transformers=[
    ('num', num_pipe, num_clos)
], remainder='passthrough')

full_pipe_rfr_label = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('model', LinearRegression())
])

# RandomForestRegressor -> 0.6672
# LinearRegression --> 0.3510

full_pipe_rfr_label.fit(house_prices[num_clos], house_prices['price'])

full_pipe_rfr_label.score(house_prices[num_clos], house_prices['price'])

def model_pipeline(base_model, cols):
    num_pipe = Pipeline(steps=[
        ('pre_process', DataTransformer(columns=cols)),
        ('imputer', SimpleImputer(strategy='median')),
        ('scaler', StandardScaler())
    ])

    preprocessor = ColumnTransformer(transformers=[
        ('num', num_pipe, cols)
    ], remainder='passthrough')

    full_pipe_rfr_label = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('model', base_model)
    ])

    full_pipe_rfr_label.fit(house_prices[cols], house_prices['price'])

    print(full_pipe_rfr_label.score(house_prices[cols], house_prices['price']))

    return full_pipe_rfr_label

from sklearn.linear_model import Ridge, Lasso

model_pipeline(Lasso(alpha=0.00001), num_clos)

model_pipeline(Ridge(alpha=100), num_clos)

